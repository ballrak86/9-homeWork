------------------------------------------------------------
Описание файлов в директории
start.sh - запрашивает нужные данные, и добавляет скрипт в cron для автоматического запуска
trap.sh - проверка что предыдущее выполнение скрипта parsingHttpdLog.sh закончилось, если нет, то ожидаем его завершения
parsingHttpdLog.sh - парсит лог apache
exampleMailToUser.txt - пример письма пользователю

------------------------------------------------------------
Описание как запустить скрипт (кратко)
Выполнить команду
Проверить что есть атрибут х у файла start.sh, если его нет то добавить через команду
chmod +x start.sh
Выполнить скрипт
./start.sh
 Ответить на заданные вопросы (на первые два вопроса можно не отвечать, а нажать Enter. Будет взято значение по умолчанию)
 Введите путь к каталогу, в котором находится файл apache (по умолчанию /var/log/)
 Введите имя файла лога apache (по умолчанию access_log)
 Введите email на который вы будете получать письма, он не может быть пустым
 alenchik@skbkontur.ru
 Для отправки почты используется mutt, просьба настройте его у себя. Спасибо
 
Проверьте что у вас установлена и настроена программа mutt. Она используется для отправки почты.

------------------------------------------------------------
Полное описание как работают скрипты

------------start.sh------------
#!/bin/bash
#Запрашиваем у пользователя примерное рассположение лог-файла apache, если пользователь ничего не заполнил, то используем директорию /var/log/
echo "Введите путь к каталогу, в котором находится файл apache (по умолчанию /var/log/)"
read directoryLog
if [ -z "$directoryLog" ];then directoryLog="/var/log/";fi

#Запрашиваем у пользователя имя лог-файла apache, если пользователь ничего не заполнил, то используем access_log
echo "Введите имя файла лога apache (по умолчанию access_log)"
read fileLog
if [ -z "$fileLog" ];then fileLog="access_log";fi

#+1 балл использование find
#Использовал find для точного определения расположения файла лога apache
fullName=$(find $directoryLog -name $fileLog)

#Запрашиваем у пользователя email на который нужно отправить полученную информацию после парсинга лог-файла, если поле пустое, запрашиваем повторно, пока не будет заполнено
while [ -z "$rootMail" ]
do
echo "Введите email на который вы будете получать письма, он не может быть пустым"
read rootMail
done

#Узнаем текущую директорию где находится исполняемый скрипт и делаем исполняемыми и другие скрипты
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
chmod +x $SCRIPT_DIR/parsingHttpdLog.sh
chmod +x $SCRIPT_DIR/trap.sh

#добавляем выполнение скрипта через cron
echo "0 * * * * root $SCRIPT_DIR/trap.sh $fullName $rootMail" >> /etc/crontab

#уведомление
echo "Для отправки почты используется mutt, просьба настройте его у себя. Спасибо"

------------trap.sh------------
#!/bin/bash
#+1 балл использование trap
#bash trap - классическая защита от повторного запуска процесса
#указываем где хранится наш pid_file, если он создан (создается и удаляется в скрипте parsingHttpdLog.sh), то ожидаем когда он будет удален. Если этого файла нет, значит скрипт parsingHttpdLog.sh выполнился
pid_file="/tmp/pidScript"
while [ -f $pid_file ]
  do
   echo "Идет фоновый процесс - ждем 300 секунд"
   sleep 300
done
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
#выполняем скрипт parsingHttpdLog.sh и передаем ему $1=путь и имя к лог-файлу apache; $2=e-mail на который нужно отправить отчет; $pid_file=pid_file
$SCRIPT_DIR/parsingHttpdLog.sh $1 $2 $pid_file


------------parsingHttpdLog.sh------------
#!/bin/bash
#####################################################
#                   functions                       #
#####################################################

#+1 балл использование функции
#функция поиска ip адресов клиентов в заданном промежутке времени. А так же подсчет количества запросов от одного и того же клиента
findXIp(){
echo "Адреса клиентов которые сделали запрос" >> /tmp/$HOSTNAME
grep $pastHour $fullFileName | cut -f1 -d' ' | sort |  uniq -c | sort -rn >> /tmp/$HOSTNAME
echo -e "\n\n" >> /tmp/$HOSTNAME
}

#+1 балл использование функции
#функция поиска адресов, которые запросил клиент в заданном промежутке времени. А так же их подсчет
findYIp(){
echo "Что запросили клиенты" >> /tmp/$HOSTNAME
grep $pastHour $fullFileName | grep "HTTP/1.1" | cut -f2 -d'"' | cut -f2 -d' ' | sort | uniq -c | sort -nr >> /tmp/$HOSTNAME
echo -e "\n\n" >> /tmp/$HOSTNAME
}

#+1 балл использование функции
#+1 балл использование sed, чтобы найти код ответа и убрать все лишнее
#функция поиска ответов с кодом ошибки. Ошибки считаются ответы 4ХХ-ошибка клиента, 5ХХ-ошибка сервера, и их подсчет
findErrorCode(){
echo "Коды ошибок 4ХХ и 5ХХ и их количество" >> /tmp/$HOSTNAME
grep $pastHour $fullFileName | grep 'HTTP/1.1" [45]' | sed 's|.*HTTP/1.1" \([0-9][0-9][0-9]\).*|\1|' | sort | uniq -c | sort -nr >> /tmp/$HOSTNAME
echo -e "\n\n" >> /tmp/$HOSTNAME
}

#+1 балл использование функции
#+1 балл использование sed, чтобы найти код ответа и убрать все лишнее
#функция поиска всех кодов ответа. И их подсчет
findAllCode(){
echo "Все коды ответов и их количество" >> /tmp/$HOSTNAME
grep $pastHour $fullFileName | grep 'HTTP/1.1"' | sed 's|.*HTTP/1.1" \([0-9][0-9][0-9]\).*|\1|' | sort | uniq -c | sort -nr >> /tmp/$HOSTNAME
echo -e "\n\n" >> /tmp/$HOSTNAME
}

#####################################################
#                    programm                       #
#####################################################
#Основная программа
> /tmp/$HOSTNAME
#Путь и имя файла лога
fullFileName=$1
#e-mail куда мы отправим отчет
eMail=$2
#Путь к pid_file и его имя 
pid_file=$3
#Так как мы запускаем скрипт каждый час, мы из текущего времени вычитаем час и используем это как шаблон для поиска в лог-файле apache
pastHour=$(date "+%d/%b/%Y:%H" -d '-1 hour')
#Записываем в pid_file id нашего процесса
echo "$$" > $pid_file
#последовательно выполняем наши функции
findXIp
findYIp
findErrorCode
findAllCode
#Отправляем на почту собранную статистику и в конце письма пишем промежуток поиска данных
echo "${pastHour}:00:00 - ${pastHour}:59:59" |  mutt -s "$HOSTNAME" -i /tmp/$HOSTNAME -- $eMail
#Удаляем pid_file
rm -f $pid_file
